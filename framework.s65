;-------------------------------------------------------------------------
; 	RASTER FX FRAMEWORK
;-------------------------------------------------------------------------
;
; From the including file:
;
; To add stuff to zero page, put .fill directives in a '.section
; zp'...'.send zp' block. These values will automatically be zeroed on
; startup.
;
; To add code, put code in a '.section code'...'.send code' block.
;
; The following routines must be provided:
;
; 1. fx_init_1 - called once, with interrupts enabled and ZP cleared, before
; anything else happens.
;
; 2. fx_init_2 - called once, roughly at start of frame, interrupts
; disabled, once things are set up
;
; 3. fx_draw - called every frame, so its first cycle is exactly at
; the top left of the visible frame
;
; 4. fx_update - called every frame to update stuff
; 
; To adjust when fx_draw is called, set draw_timer_adjustment - units
; are microseconds. Positive values will cause fx_draw to be called
; earlier, so that the first useful write can line up with the start
; of the visible display.
; 
;-------------------------------------------------------------------------
; 	OS defines
;-------------------------------------------------------------------------

osnewl=$ffe7
osfile = $FFDD
oswrch = $FFEE
osasci = $FFE3
osbyte = $FFF4
osword = $FFF1
osfind = $FFCE
osgbpb = $FFD1
osargs = $FFDA
oscli=$fff7

;-------------------------------------------------------------------------

mode2_palette .function index,physical
                .endf (index<<4)|(physical^7)

                ; this produces the left value
mode2_left .function index
                .endf ((index&8)<<4)|((index&4)<<3)|((index&2)<<2)|((index&1)<<1)

mode2_right .function index
                .endf mode2_left(index)>>1

mode2_value .function left,right
                .endf mode2_left(left)|mode2_right(right)

                ; http://6502.org/tutorials/65c02opcodes.html

nop1 .macro
                .byte $03       ; 1 cycle
                .endm

nops: .macro ncycles

n:=\ncycles
                .rept n/12
                jsr cycles_wait_12
n:=n-12
                .next

                .rept n/2
                nop
n:=n-2
                .next

                .if n%2==1
                .nop1
                .endif
                
                .endm

crtc_addr .function addr
                .cerror (addr&7)!=0,"invalid CRTC addr"
                .endf addr>>3
                
;-------------------------------------------------------------------------

                .weak
draw_timer_adjustment=0
                .endweak
                
video_control=$fe20   
video_palette=$fe21
acccon=$fe34
romsel=$fe30

; Exact time for a 50Hz frame less latch load time
FramePeriod = 312*64-2

; First timer value - times from vsync interrupt to wherever the
; fx_init_function should get called.
;
; This value is for the Mode 2 default CRTC values, with R5=0 and
; interlace off:
;
; 40 is the vblank length (312-272);
;
; 2 is the vblank period (the IRQ occurs on scanline 274)
;
; 9 accounts for the time taken to load the timer value the first
; time round;
;
; 2 is the latch load time (???).
;
; (-2-9 puts the start of fx_init_function at the top left of the
; screen. Subtract more cycles to shift it further back.)
TimerValue = 40*64 - 2*64 - 2 - 9 - draw_timer_adjustment

; 40 lines for vblank
; 32 lines for vsync (vertical position = 35 / 39)
; interupt arrives 2 lines after vsync pulse
; 2 us for latch
; XX us to fire the timer before the start of the scanline so first colour set on column -1
; YY us for code that executes after timer interupt fires

;-------------------------------------------------------------------------
; 	ZERO PAGE
;-------------------------------------------------------------------------

*=$70
zp_start:
                .dsection zp
                .cerror *>=$9f,"ZP overflow"
zp_end:       

                .section zp
vsync_counter: .fill 2		; counts up with each vsync
; escape_pressed: .fill 1         ; set when Escape key pressed
                .send

;-------------------------------------------------------------------------

*=$1900
                .dsection code
                .cerror *>=$3000,"main RAM overflow"

;-------------------------------------------------------------------------
; 	Code entry
;-------------------------------------------------------------------------

                .section code
main: .proc
; Set interrupts
                ; Initalise system vars

                ldx #zp_start
                lda #0
-
                sta 0,x
                inx
                cpx #zp_end
                bne -

                ; Initialise system modules here!
                ; Load SIDEWAYS RAM modules here!
                jsr fx_init_1

                ; Turn off interlace
                lda #8
                sta $fe00
                lda #0
                sta $fe01

                ; Turn off cursor
                lda #10
                sta $FE00
                lda #32
                sta $FE01

                ; Reset *TV effect
                lda #5
                sta $fe00
                lda #0
                sta $fe01

                lda #19
                jsr osbyte

                sei        ; disable interupts
                lda #$7F   ; A=01111111
                sta $FE4E  ; R14=Interrupt Enable (disable all interrupts)
                sta $FE43 ; R3=Data Direction Register "A" (set keyboard data
                ; direction)
                lda #$C2  ; A=11000010
                sta $FE4E ; R14=Interrupt Enable (enable main_vsync and timer
                ; interrupt)
                ; cli       ; enable interupts


                ; DEMO START - from here on out there are no interrupts enabled!!

                ; sei

                ; jsr fx_kill_function

                ; Exact cycle VSYNC by Hexwab

		lda #2
-
		bit $FE4D
		beq -           ; wait for vsync

		;now we're within 10 cycles of vsync having hit

		;delay just less than one frame
syncloop:
		sta $FE4D ; 4(stretched), ack vsync

		;{ this takes (5*ycount+2+4)*xcount cycles
		;x=55,y=142 -> 39902 cycles. one frame=39936
		ldx #142 ;2
deloop:
		ldy #55 ;2
innerloop:
		dey ;2
		bne innerloop ;3
		; =152
		dex ; 2
		bne deloop ;3
		;}

                ldx #<TimerValue ; nop
                ldy #>TimerValue ; nop
                nop
                nop
                nop
                nop
                nop
                nop
                nop ; +16
                
		bit $FE4D ;4(stretched)
		bne syncloop ; +3
		; 4+39902+16+4+3+3 = 39932
		; ne means vsync has hit
		; loop until it hasn't hit

		;now we're synced to vsync

                ; Set up Timers

set_timers:
                ; Write T1 low now (the timer will not be written
                ; until you write the high byte)
                ; lda #<TimerValue
                stx $FE44
                
                ; Get high byte ready so we can write it as quickly as
                ; possible at the right moment
                ; ldx #>TimerValue
                sty $FE45  ; start T1 counting ; 4c +1/2c

                ; Latch T1 to interupt exactly every 50Hz frame
                lda #<FramePeriod
                sta $FE46
                lda #>FramePeriod
                sta $FE47

                ; Initialise FX modules here

call_init:
                jsr fx_init_2

                ; We don't know how long the init took so resync to timer 1

		lda #$42
		sta $FE4D	; clear vsync $ timer 1 flags

		; Wait for Timer1 at rasterline 0

		lda #$40
-
		bit $FE4D
		beq -
		sta $FE4D

		; Now can enter main loop with enough time to do work

                ; Update typically happens during vblank so wait 255 lines
                ; But don't forget that the loop also takes time!!

		ldx #245
-
		jsr cycles_wait_128
		dex
		bne -

                ; MAIN LOOP

main_loop:

                ;  Do useful work during vblank (vsync will occur at
                ;  some point)
		inc vsync_counter
		bne +
		inc vsync_counter+1
+

; Service any system modules here!

; ; Check for Escape key

;                 lda #$79
;                 ldx #($70 ^ $80)
;                 jsr osbyte
;                 stx escape_pressed

                ; FX update callback here!

call_update:
                jsr fx_update

                ; Wait for first scanline

                ; Wait for T1<256
-
                lda $fe45
                bne -

-
                lda $fe44
                .nop1           ;+1 1    1
                cmp #12         ;+2 3    3
                bcs -           ;+2 5 +3 6 
                .nop1           ;+1 6
                asl a           ;+2 8
                tax             ;+2 10
                jmp (dejitter_routines,x) ;+6 16/8

dejitter_4:
                nop
dejitter_3:
                nop
dejitter_2:
                nop
dejitter_1:
                nop

call_draw:
                jsr fx_draw
                
                ; Loop as fast as possible

                jmp main_loop

                ; Get current module to return CRTC to known state

; call_kill:
;                 jsr fx_kill_function

;                 ; Re-enable useful interupts

;                 lda #$D3        ; A=11010011
;                 sta $FE4E       ; R14=Interrupt Enable
;                 cli

;                 ; Exit gracefully (in theory)

;                 rts

dejitter_routines:
                .word call_draw ;0
                .word call_draw ;1
                .word call_draw ;2
                .word call_draw ;3
                .word call_draw ;4
                .word call_draw ;5
                .word call_draw ;6
                .word call_draw ;7
                .word dejitter_1 ;8
                .word dejitter_2 ;9
                .word dejitter_3 ;10
                .word dejitter_4 ;11
                
                .pend
                
;-------------------------------------------------------------------------
; 	HELPER FUNCTIONS
;-------------------------------------------------------------------------

                
cycles_wait_128:	;	JSR to get here takes 6c
                .rept 58
                nop
                .next
cycles_wait_12:
                rts

                .send code
