;-------------------------------------------------------------------------
; 	RASTER FX FRAMEWORK
;-------------------------------------------------------------------------
;
; From the including file:
;
; To add stuff to zero page, put .fill directives in a '.section
; zp'...'.send zp' block. These values will automatically be zeroed on
; startup.
;
; To add code, put code in a '.section code'...'.send code' block.
;
; The following routines must be provided:
;
; 1. fx_init_1 - called once, with interrupts enabled and ZP cleared, before
; anything else happens.
;
; 2. fx_init_2 - called once, roughly at start of frame, interrupts
; disabled, once things are set up
;
; 3. fx_draw - called every frame, so its first cycle is exactly at
; the top left of the visible frame
;
; 4. fx_update - called every frame to update stuff
; 
; To adjust when fx_draw is called, set draw_timer_adjustment - units
; are microseconds. Positive values will cause fx_draw to be called
; earlier, so that the first useful write can line up with the start
; of the visible display.
; 
;-------------------------------------------------------------------------
; 	OS defines
;-------------------------------------------------------------------------

osnewl=$ffe7
osfile = $FFDD
oswrch = $FFEE
osasci = $FFE3
osbyte = $FFF4
osword = $FFF1
osfind = $FFCE
osgbpb = $FFD1
osargs = $FFDA
oscli=$fff7

;-------------------------------------------------------------------------

mode2_palette .function index,physical
                .endf (index<<4)|(physical^7)

                ; this produces the left value
mode2_left .function index
                .endf ((index&8)<<4)|((index&4)<<3)|((index&2)<<2)|((index&1)<<1)

mode2_right .function index
                .endf mode2_left(index)>>1

mode2_value .function left,right
                .endf mode2_left(left)|mode2_right(right)

                ; http://6502.org/tutorials/65c02opcodes.html

nops: .macro ncycles
n:=\ncycles

                .cerror n==1,"can't delay for just 1 cycle"

                .if n%2==1
                sta nops_tmp
n:=n-3
                .endif

                .rept n/128
                jsr cycles_wait_128
n:=n-128
                .next
                
                .rept n/12
                jsr cycles_wait_12
n:=n-12
                .next

                .rept n/2
                nop
                .next
                
                .endm

crtc_addr .function addr
                .cerror (addr&7)!=0,"invalid CRTC addr"
                .endf addr>>3

                ; 16 cycles
crtc: .macro r,v
                lda #\r
                sta $fe00
                lda #\v
                sta $fe01
                .endm
                

;-------------------------------------------------------------------------

                .weak
draw_timer_adjustment=0
                .endweak
                
video_control=$fe20   
video_palette=$fe21
acccon=$fe34
romsel=$fe30

; Exact time for a 50Hz frame less latch load time
FramePeriod = 312*64-2

; First timer value - times from vsync interrupt to wherever the
; fx_init_function should get called.
;
; This value is for the Mode 2 default CRTC values, with R5=0 and
; interlace off:
;
; 40 is the vblank length (312-272);
;
; 2 is the vblank period (the IRQ occurs on scanline 274);
;
; 7 can probably go away, but I haven't sat down and done that;
;
; 2 is the latch load time (???).
;
; (-2-7 puts the start of fx_init_function at the top left of the
; screen. Subtract more cycles to shift it further back.)
TimerValue = 40*64 - 2*64 - 2 - 7 - draw_timer_adjustment

; 40 lines for vblank
; 32 lines for vsync (vertical position = 35 / 39)
; interupt arrives 2 lines after vsync pulse
; 2 us for latch
; XX us to fire the timer before the start of the scanline so first colour set on column -1
; YY us for code that executes after timer interupt fires

;-------------------------------------------------------------------------
; 	ZERO PAGE
;-------------------------------------------------------------------------

*=$70
zp_start:
                .dsection zp
                .cerror *>=$9f,"ZP overflow"
zp_end:       

                .section zp
vsync_counter: .fill 2		; counts up with each vsync
nops_tmp: .fill 1               ; may be overwritten by .nops macro
                .send

;-------------------------------------------------------------------------

*=$1900
                .dsection code
                .cerror *>=$3000,"main RAM overflow"

;-------------------------------------------------------------------------
; 	Code entry
;-------------------------------------------------------------------------

                .section code
main: .proc
; Set interrupts
                ; Initalise system vars

                ldx #zp_start
                lda #0
-
                sta 0,x
                inx
                cpx #zp_end
                bne -

                ; Initialise system modules here!
                ; Load SIDEWAYS RAM modules here!
                jsr fx_init_1

                ; Turn off interlace
                lda #8
                sta $fe00
                lda #0
                sta $fe01

                ; Turn off cursor
                lda #10
                sta $FE00
                lda #32
                sta $FE01

                ; Reset *TV effect
                lda #5
                sta $fe00
                lda #0
                sta $fe01

                lda #19
                jsr osbyte

                sei        ; disable interupts
                lda #$7F   ; A=01111111
                sta $FE4E  ; R14=Interrupt Enable (disable all interrupts)
                sta $FE43 ; R3=Data Direction Register "A" (set
                          ; keyboard data direction)
                lda #$C2  ; A=11000010
                sta $FE4E ; R14=Interrupt Enable (enable main_vsync
                          ; and timer interrupt)

                ; http://www.retrosoftware.co.uk/wiki/index.php?title=Reading_the_keyboard_by_direct_hardware_access
                lda #$0f
                sta $fe42
                lda #$03
                sta $fe40

                ; DEMO START - from here on out there are no interrupts enabled!!

                ; sei

                ; jsr fx_kill_function

                ; Exact cycle VSYNC by Hexwab

		lda #2
-
		bit $FE4D
		beq -           ; wait for vsync

		;now we're within 10 cycles of vsync having hit

		;delay just less than one frame
syncloop:
		sta $FE4D ; 4(stretched), ack vsync

		;{ this takes (5*ycount+2+4)*xcount cycles
		;x=55,y=142 -> 39902 cycles. one frame=39936
		ldx #142 ;2
deloop:
		ldy #55 ;2
innerloop:
		dey ;2
		bne innerloop ;3
		; =152
		dex ; 2
		bne deloop ;3
		;}

                ldx #<TimerValue ; nop
                ldy #>TimerValue ; nop
                nop
                nop
                nop
                nop
                nop
                nop
                nop ; +16
                
		bit $FE4D ;4(stretched)
		bne syncloop ; +3
		; 4+39902+16+4+3+3 = 39932
		; ne means vsync has hit
		; loop until it hasn't hit

		;now we're synced to vsync

                ; Set up Timers

set_timers:
                ; Write T1 low now (the timer will not be written
                ; until you write the high byte)
                ; lda #<TimerValue
                stx $FE44
                
                ; Get high byte ready so we can write it as quickly as
                ; possible at the right moment
                ; ldx #>TimerValue
                sty $FE45  ; start T1 counting ; 4c +1/2c

                ; Latch T1 to interupt exactly every 50Hz frame
                lda #<FramePeriod
                sta $FE46
                lda #>FramePeriod
                sta $FE47

                ; Initialise FX modules here

call_init:
                jsr fx_init_2

                ; We don't know how long the init took so resync to timer 1

		lda #$42
		sta $FE4D	; clear vsync $ timer 1 flags

		; Wait for Timer1 at rasterline 0

		lda #$40
-
		bit $FE4D
		beq -
		sta $FE4D

		; Now can enter main loop with enough time to do work

                ; Update typically happens during vblank so wait 255 lines
                ; But don't forget that the loop also takes time!!

		ldx #245
-
		jsr cycles_wait_128
		dex
		bne -

                ; MAIN LOOP

main_loop:

                ;  Do useful work during vblank (vsync will occur at
                ;  some point)
		inc vsync_counter
		bne +
		inc vsync_counter+1
+

; Service any system modules here!

; ; Check for Escape key

;                 lda #$79
;                 ldx #($70 ^ $80)
;                 jsr osbyte
;                 stx escape_pressed

                ; FX update callback here!

call_update:
                jsr fx_update

                ; Wait for first scanline

                ; Wait for T1<256
-
                lda $fe45
                bne -

                .page
-
                ldx $fe44
                cpx #19                ;+2 2
                bcs -                  ;+2 4
                lda dejitter_offsets,x ;+4 8
                sta dejitter_jmp+1     ;+4 12
dejitter_jmp:
                jmp dejitter_jmp&$ff00 ;+3 18
                ;jsr = +6 24

case_18:
                nop
case_17:
                nop
case_16:
                nop
case_15:
                nop
case_14:
                nop
case_13:
                nop
case_12:
                nop
case_11:
                nop
case_10:
                nop
no_delay:
                jsr fx_draw
                jmp main_loop

dejitter: .macro dest
                .byte \dest&$ff
                .endm
                
dejitter_offsets:
                .rept 10
                .dejitter no_delay
                .next
                .dejitter case_10
                .dejitter case_11
                .dejitter case_12
                .dejitter case_13
                .dejitter case_14
                .dejitter case_15
                .dejitter case_16
                .dejitter case_17
                .dejitter case_18
                .endp

                .pend
                
;-------------------------------------------------------------------------
; 	HELPER FUNCTIONS
;-------------------------------------------------------------------------

                
cycles_wait_128:	;	JSR to get here takes 6c
                .rept 58
                nop
                .next
cycles_wait_12:
                rts

load_mode2_screen: .proc
                lda #22
                jsr oswrch

                lda #2
                jsr oswrch

                ldx #<load_screen
                ldy >#load_screen
                jsr oscli

                rts

load_screen:
                .text "LOAD $.SCREEN",13
                .pend

;-------------------------------------------------------------------------

                .send code
